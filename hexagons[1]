<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Hexagonal Grids</title><meta name="viewport" content="width=640"><link rel="shortcut icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/red%20blob%202d.png"><link href="https://fonts.googleapis.com/css?family=Roboto+Slab:700%7COpen+Sans'%20rel='stylesheet"><link href="//disqus.com/embed/comments/" rel="preconnect"><link href="//a.disquscdn.com/" rel="preconnect"><link rel="canonical" href="http://www.redblobgames.com/grids/hexagons/"><link rel="alternate" type="application/atom+xml" title="Blobs in Games - Atom" href="http://simblob.blogspot.com/feeds/posts/default"><meta name="twitter:creator" content="@redblobgames"><meta name="verify-v1" content="82b+h1+tgwLrcTqTiJrqquMvoFVBwMwY11dx63m01zk="><meta name="robots" content="noodp"><!-- D3 --><script src="/js/d3.v3.min.js"></script><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@redblobgames"><meta name="twitter:title" content="Red Blob Games: Hexagonal Grids"><meta name="twitter:description" content="Guide to math, algorithms, and code for hexagonal grids in games"><meta name="twitter:image" content="http://www.redblobgames.com/thumbnail/hexagons.png"><script><!--
            (function() {
            var link = document.createElement('link');
            link.href = 'http://fonts.googleapis.com/css?family=Source+Code+Pro:400,700|Source+Sans+Pro:400,400italic,700italic,700';
            link.rel = 'stylesheet';
            link.type = 'text/css';
            if (document.location.hostname != 'localhost') document.getElementsByTagName('html')[0].appendChild(link);
            })();
          //--></script><style>
              body{font-family:"Source Sans Pro", "Open Sans", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Tahoma", sans-serif;font-size:14px;line-height:1.5;min-height:95%}body.width600{font-size:16px}tt,code,kbd,samp,pre{font-family:"Source Code Pro", monospace, serif, "Segoe UI Symbol", "Symbol";font-size:12px;font-size-adjust:none}.width600 tt,.width600 code,.width600 kbd,.width600 samp,.width600 pre{font-size:14px}nav{font-size:14px}header,h2{text-shadow:0px 2px 5px rgba(0,0,0,0.8);text-rendering:optimizeLegibility;-webkit-font-feature-settings:"kern";-moz-font-feature-settings:"kern";-moz-font-feature-settings:"liga=1,pnum=1,onum=1,kern=1";-ms-font-feature-settings:"liga" 1, "pnum" 1, "onum" 1, "kern" 1;font-kerning:normal}h1{font-size:28px}h1 .subheading{letter-spacing:normal;font-size:14px}.width600 h1{font-size:32px}.width600 h1 .subheading{font-size:16px}sup,sub{position:relative;vertical-align:baseline;font-size:75%;line-height:0;padding-left:2px}sup{top:-0.5em}sub{bottom:-0.25em}*{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html,body{margin:0;padding:0}body{background-color:#fff;color:#333}.main{max-width:1075px;margin-left:auto;margin-right:auto;padding:0 40px}header{display:block;text-align:center}h1{margin:0;padding:28px;padding-left:80px;text-align:left}.colored-background{color:#fff;background-color:#bf4040}header,.footer,.divider,h2{color:#fff;background-color:#bf4040;-webkit-font-smoothing:antialiased}header a,.footer a,.divider a,h2 a{color:#f2d9d9}.footer a,.divider a{text-decoration:underline}.comments,.divider-disqus{background-color:#e4e4e0}.comments{padding-bottom:20px;text-shadow:1px 1px 3px #fff}h2{margin:20px 0;padding:10px 40px;font-size:20px;max-width:530px}.width600 h2{max-width:680px}h2 a.anchor{float:right;width:2em;text-align:right;color:#bf4040}h2:hover a.anchor{color:#df9f9f}h3{margin:18px 0;font-size:18px}nav{display:block}nav ul{text-align:center;line-height:1.0;margin:0}nav ul li{display:inline-block;padding:2px 5px;text-align:center;width:10%;white-space:nowrap}nav ul li a{display:block;width:100%;font-weight:bold;text-decoration:none}nav ul li.nav:hover{background-color:rgba(0,0,0,0.5);font-weight:bold}nav ul li.navself{background-color:rgba(0,0,0,0.3);font-weight:bold}.topic{margin-left:40px;margin-right:40px;margin-bottom:35px;max-width:450px}.width600 .topic{max-width:600px}header,.divider,h2{border-bottom:1px solid #000}.divider,.footer,h2{border-top:1px solid #000}.divider{min-height:28px;padding-left:2.5em}.divider-disqus{padding-top:14px;text-align:center}.footer{clear:both;padding:7px 14px;border-top:1px solid #000}.footer p{max-width:40em;line-height:1.1}h2:target{-webkit-animation:target-attention 0.4s 1;-moz-animation:target-attention 0.4s 1}@-webkit-keyframes target-attention{0%{-webkit-transform:scale(1.1);transform:scale(1.1)}100%{-webkit-transform:scale(1);transform:scale(1.1)}}@-moz-keyframes target-attention{0%{-moz-transform:scale(1.1);transform:scale(1.1)}100%{-moz-transform:scale(1);transform:scale(1)}}h2:target{font-size:24px}div:target{border:1px dashed #888}kbd kbd{padding:1px 7px;margin:0px 1px 3px 1px;display:inline-block;font-size:11px;font-family:"Helvetica Neue", "Helvetica", "Tahoma", "Arial", sans-serif;white-space:nowrap;background:#ddd;color:#242;border:1px solid rgba(0,0,0,0.2);border-radius:3px;box-shadow:inset 0 0 1px 1px #fff,0 2px 0 rgba(0,0,0,0.3)}samp,kbd{background-color:#f4f4f0}code,samp{color:#442}kbd{margin:0 7px;color:#252}.topic>img{max-width:100%;-ms-interpolation-mode:bicubic}.topic figcaption{font-size:12px;text-align:center}a{color:#bf4040;text-decoration:none}a:hover{text-decoration:underline}.topic p,.topic li{text-align:justify;-moz-hyphens:auto;-ms-hyphens:auto;-webkit-hyphens:auto;hyphens:auto}nav,figure,abbr,acronym,code,kbd,samp,tt,var,pre{-moz-hyphens:none;-ms-hyphens:none;-webkit-hyphens:none;hyphens:none}p,ul,ol,ul.spaced>li,ol.spaced>li{margin:1.25em 0}ul ul,ul ol,ol ul,ol ol,li ul,li ol{margin:0}ul,ol{margin-left:0;padding-left:21px}dt{font-weight:bold}pre{max-width:450px;line-height:1.4;font-size:12px;padding:4px 12px;overflow:auto;white-space:pre-wrap;border-top:1px solid #ccc;border-bottom:1px solid #ccc;border-left-width:0;border-right-width:0}.width600 pre{max-width:600px}.width600 pre{font-size:14px}pre::-webkit-scrollbar{height:1em}pre::-webkit-scrollbar-thumb:horizontal{border-radius:0.5em;background:rgba(0,0,0,0.4)}ul pre,ol pre{width:450px}pre.simple,.comments pre{overflow:visible;width:100%;border:none;background:transparent;background-color:transparent;box-shadow:none}pre.snippet,pre.src{border-top-style:dashed;border-bottom-style:dashed}.topic>pre:only-child{padding-bottom:14px;border-bottom:1px solid rgba(0,0,0,0.5)}blockquote{font-style:italic}table.standard{border:1px solid rgba(0,0,0,0.5);border-collapse:collapse}table.standard th{background-color:#f8f8f8;background:linear-gradient(to bottom, #f8f8f8,#f8f8f8,#f0f0f0)}table.standard td{background-color:#fff}table.standard th,table.standard td{border:1px solid rgba(0,0,0,0.5)}p.note,div.note>p{margin:1em;padding:1em;background:#eee;border:1px solid #ddd;box-shadow:0 8px 6px -6px rgba(0,0,0,0.4)}svg{overflow:hidden}tt,code{padding:0 2px}address{max-width:450px;text-align:right}.footer address{text-align:left}@media only screen and (max-width: 700px){.main{padding:0 10px}.topic{margin-left:10px;margin-right:10px}h2{max-width:400px}pre{font-size:10px}.width600 pre{font-size:11px}nav{font-size:12px}}@media only screen and (max-width: 600px){header,.footer{font-size:12px}h1{text-align:center;font-size:14px;padding:14px}nav span.longnav,nav form{display:none}nav ul li{width:15%}.omit-if-narrow,nav ul li.omit-if-narrow{display:none}pre{width:auto;font-size:9px}nav{font-size:10px}}form{margin:0}input[type="text"]{max-width:100%;border:1px solid rgba(0,0,0,0.7);background-color:#f8f8f4;color:#000;text-align:center;font-weight:bold}input[type="text"]:focus{background-color:#fffff4}input::-webkit-input-placeholder{color:#aaa}input::-moz-placeholder{color:#aaa}.TODO{color:#bf4040;background:#e8e3e3;border:1px solid #bf4040;margin-left:0.5ex}.DONE{color:#4040bf;background:#e3e3e8;border:1px solid #4040bf}pre.src .comment-delimiter,pre.src .nxml-comment-delimiter{color:#4488ff}pre.src .comment,pre.src .nxml-comment-content{color:#006699}pre.src .keyword{color:#406abf;font-weight:bold}pre.src .builtin{color:#508b20}pre.src .warning{color:#cc0000}pre.src .function-name{color:#268bd2;font-weight:bold}pre.src .variable-name{color:#00008b}pre.src .type{color:#6c71c4}pre.src .constant-face{color:#d33682}pre.src .doc{color:#666666;background-color:#e2e6e8}pre.src .string{color:#888888}pre.src .preprocessor{color:#859900}pre.src .negation-char,pre.src .sh-escaped-newline{color:#ff0000}pre.src .todo{color:#ffffff;background:#dc322f}pre.src .note{color:#ffffff;background:#2aa198}pre.src .hack{color:#ffffff;background:#859900}pre.src .paren{color:#a0a090;font-weight:bold}pre.src .minor-control-construct{color:#268bd2}pre.src .major-control-construct{color:#bf4040}pre.src-emacs-lisp .paren{color:#c9c9c4}pre.src-sh .string,pre.src-sh .comment{color:inherit}pre.src-python .highlight-indentation{border-right:2px solid #eeeeee}pre.src-xml .nxml-element-local-name{color:#406abf;font-weight:normal}pre.src-xml .nxml-tag-delimiter,pre.src-xml .nxml-tag-slash{color:#9cabc9;font-weight:bold}table.standard td.left,table.standard th.left{text-align:left}table.standard td.center,table.standard th.center{text-align:center}table.standard td.right,table.standard th.right{text-align:right}*[class^="section-number"]{color:#966}h2 *[class^="section-number"]{color:#e6b3b3;text-align:right;display:inline-block;margin-left:-40px;width:40px}h3 *[class^="section-number"]{color:#e6b3b3;background-color:#bf4040;border-top:1px solid black;border-bottom:1px solid black;text-shadow:0px 2px 5px rgba(0,0,0,0.8);text-rendering:optimizeLegibility;text-align:center;display:inline-block;padding:4px 0;width:40px;margin-left:-40px}@media only screen and (max-width: 700px){h3 *[class^="section-number"]{margin-left:-10px}}#table-of-contents{background-color:#fff;margin-left:40px;padding-left:40px;width:300px;float:right}#table-of-contents:after{clear:both}#table-of-contents h2{text-shadow:none;color:#000;background-color:transparent;background-image:none;padding:0;border-bottom:none;border-top:none}@media print{body{font-family:"Book Antiqua", "Times New Roman", serif;font-size:12pt;line-height:1.25}h1,h2,h3,h4,h5,h6,.footer,.divider-disqus{font-family:"Helvetica", sans-serif;font-size:12pt;text-rendering:optimizeLegibility}h1{font-size:18pt}h1 .subheading{font-size:12pt}header,h2{text-shadow:none}tt,code,kbd,samp,pre{font-family:"Courier", "Courier New", monospace;font-size:12pt}nav,.comments{display:none}}header,.footer,.divider,h2{background-image:url("/img/transparent-blob.png"),url("/img/transparent-blob.png");background-position:0 0, 16px 16px}

            
    header, .footer, .divider, h2 {
      /* Override the blob image */
      /* This background from http://philbit.com/svgpatterns/#honeycomb */
      background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyOCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDU2IDEwMCI+CjxyZWN0IHdpZHRoPSI1NiIgaGVpZ2h0PSIxMDAiIGZpbGw9ImhzbCgwLDUwJSw1MCUpIj48L3JlY3Q+CjxwYXRoIGQ9Ik0yOCA2NkwwIDUwTDAgMTZMMjggMEw1NiAxNkw1NiA1MEwyOCA2NkwyOCAxMDAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iaHNsKDAsNTAlLDQwJSkiIHN0cm9rZS13aWR0aD0iMiI+PC9wYXRoPgo8cGF0aCBkPSJNMjggMEwyOCAzNEwwIDUwTDAgODRMMjggMTAwTDU2IDg0TDU2IDUwTDI4IDM0IiBmaWxsPSJub25lIiBzdHJva2U9ImhzbCgwLDUwJSw0NSUpIiBzdHJva2Utd2lkdGg9IjEuNSI+PC9wYXRoPgo8L3N2Zz4=");
      }
  
@media only screen and (min-width: 1375px) {
    .main {
        max-width: 1375px;
    }
    .width600 div.topic {
        max-width: 1375px;
    }
    .width600 div.topic > * {
        max-width: 600px;
    }
    div.topic > .float-container {
        max-width: inherit;
    }
    #toc {
        width: 300px;
        float: right;
        margin-left: 100px;
    }
}

.h2banner, h2, h3, .float-container {
    clear: both;
}

.float-container > * {
    float: left;
    clear: left;
    width: 600px;
}
.float-container > .float-right {
    float: right;
    clear: right;
}

.float-container > p:first-child, .float-container > div:first-child > p:first-child {
    /* Hack to deal with margin outside float not overlapping with margin inside float */
    margin-top: 0;
}

#toc {
    -webkit-columns: 180px;
    -moz-columns: 180px;
    columns: 180px;
    list-style-type: square;
    list-style-position: inside;
    list-style-image: url("hexagon-bullet.svg");
}
    
pre {
    /* This style matches the diagrams */
    background: hsl(60, 10%, 95%);
    border-color: hsla(0, 0%, 70%, 0.5);
    box-shadow: none;
}

button {
    font-weight: bold;
    font-size: inherit;
    font-family: inherit;
    border: 1px outset hsl(0, 24%, 95%);
    border-radius: 4px;
    background: hsl(0, 24%, 95%);
    margin: 4px;
    padding: 2px;
    -webkit-appearance:none;
    cursor: pointer;
}
    
button.highlight {
    border-color: hsl(0, 24%, 80%);
    background: hsl(0, 24%, 80%);
    box-shadow: 1px 1px 3px hsla(0, 0%, 0%, 0.2);
}
    
button:hover {
    border-color: hsl(0, 48%, 46%);
    background: hsl(0, 48%, 46%);
    color: hsl(0, 0%, 100%);
    box-shadow: 1px 1px 3px hsla(0, 0%, 0%, 0.5);
}

.diagram {
    width: 600px;
    text-align: center;
}
    
svg {
    pointer-events: visiblePainted;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}

svg > * {
    pointer-events: none;
}

.cube {
    -webkit-transform: translateX(0);
    transform: translateX(0);
    -webkit-transition: -webkit-transform 2s ease-in-out 0;
    transition: transform 2s ease-in-out;
}
.cube path {
    stroke: hsl(60, 10%, 80%);
    stroke-width: 1px;
}
.cube.base path {
    stroke: hsl(60, 10%, 85%);
}
.cube .full {
    fill: hsl(60, 10%, 90%);
    stroke: hsl(60, 10%, 70%);
    stroke-width: 1px;
}
.cube.base .full {
    stroke: hsl(60, 10%, 65%);
}
.cube .shade {
    fill: hsl(60, 10%, 80%);
    stroke: hsl(60, 10%, 70%);
    stroke-width: 1px;
}
.cube.base .shade {
    fill: hsl(60, 10%, 90%);
    stroke: hsl(60, 10%, 65%);
}
.cube.offscreen {
    -webkit-transform: translateX(375px);
    transform: translateX(375px);
}

text {
    font-size: 14px;
    text-anchor: middle;
}

#neighbors-cube text, #neighbors-axial text {
    font-size: 20px;
}

#grid-axial text {
    font-size: 16px;
}

.tile polygon, #diagram-map-storage-array rect {
    pointer-events: visiblePainted;
    fill: hsl(60, 10%, 95%);
    stroke: hsl(0, 0%, 70%);
    stroke-width: 0.5;
}

.tile.q-axis-same polygon { fill: hsl( 90, 20%, 87%); }
.tile.r-axis-same polygon { fill: hsl(200, 15%, 90%); }
.tile.s-axis-same polygon { fill: hsl(300, 10%, 90%); }
.tile.q-axis-same.r-axis-same polygon { fill: hsl(160, 20%, 80%); }
.tile.q-axis-same tspan.q { fill: hsl( 90, 100%, 35%); font-weight: bold; }
.tile.r-axis-same tspan.r { fill: hsl(200, 100%, 45%); font-weight: bold; }
.tile.s-axis-same tspan.s { fill: hsl(300,  80%, 50%); font-weight: bold; }

/* Some of these classes are used for both svg ("stroke") and html ("color") */
.x-axis, .q-axis { color: hsl(90, 100%, 25%); stroke: hsl( 90, 100%, 35%); stroke-width: 2px; }
.y-axis { color: hsl(300, 80%, 40%); stroke: hsl(300,  80%, 50%); stroke-width: 2px; }
.z-axis, .r-axis { color: hsl(200, 100%, 35%); stroke: hsl(200, 100%, 45%); stroke-width: 2px; }
#grid-comparison .x-axis, #grid-comparison .q-axis { fill: hsl( 90, 50%, 35%); }
#grid-comparison .y-axis { fill: hsl(300, 40%, 50%); }
#grid-comparison .z-axis, #grid-comparison .r-axis { fill: hsl(200, 50%, 45%); }
#grid-comparison path { fill-opacity: 0.5; stroke-opacity: 0.5; }

#grid-comparison text {
    font-size: 20px;
}

#diagram-hex-to-pixel path { fill: hsl(200, 50%, 70%); fill-opacity: 0.5; stroke: hsl(200, 50%, 30%); stroke-width: 1.0; stroke-opacity: 0.3; }
#diagram-pixel-to-hex .highlight polygon { fill: hsl(200, 50%, 80%); }

#diagram-line .selected polygon {fill: hsl(200, 50%, 80%); }

.neighbors-code span.highlight { background: hsl(200, 50%, 80%); }
.neighbors .highlight polygon { fill: hsl(200, 50%, 80%); }
#neighbors-diagonal .highlight polygon { fill: hsl(200, 20%, 90%); }

#diagram-rotation .right2 polygon { fill: hsl(300, 20%, 80%); }
#diagram-rotation .left2  polygon { fill: hsl(120, 20%, 80%); }
#diagram-rotation .right1 polygon { fill: hsl(300, 40%, 80%); }
#diagram-rotation .left1  polygon { fill: hsl(120, 40%, 80%); }
#diagram-rotation .opposite polygon { fill: hsl(200, 20%, 80%); }
#diagram-rotation .center polygon { fill: hsl(  0,  0%, 60%); }
#diagram-rotation .target polygon { fill: hsl(200, 50%, 80%); }
#diagram-rotation .arrow { fill-opacity: 0.5; stroke-width: 1.0; stroke-opacity: 0.3; }
#diagram-rotation .arrow.right  { fill: hsl(300, 50%, 70%); stroke: hsl(300, 50%, 30%); }
#diagram-rotation .arrow.left   { fill: hsl(120, 50%, 70%); stroke: hsl(120, 50%, 30%); }
#diagram-rotation .arrow.target { fill: hsl(200, 50%, 70%); stroke: hsl(200, 50%, 30%); }
#diagram-rotation text { fill: hsl(0, 0%, 80%); }
#diagram-rotation .left1 text,
#diagram-rotation .left2 text,
#diagram-rotation .right1 text,
#diagram-rotation .right2 text,
#diagram-rotation .opposite text,
#diagram-rotation .target text,
#diagram-rotation .center text { fill: hsl(0, 0%, 0%); }

#diagram-rings .arrow,
#diagram-spiral .arrow
{ fill: hsl(200, 50%, 50%); fill-opacity: 0.5; stroke: hsl(200, 50%, 30%); stroke-width: 1.0; stroke-opacity: 0.3; }
#diagram-rings .arrow-first
{ fill: hsl(200, 0%, 50%); stroke: hsl(200, 0%, 50%); }
#diagram-rings .ring polygon,
#diagram-spiral .ring polygon
{ fill: hsl(200, 50%, 80%); }

#diagram-hex-range .region polygon { fill:hsl(200,  40%, 80%); }
#diagram-hex-range line { stroke-opacity: 50%; }

#diagram-distances text { fill: hsl(0, 0%, 80%); }
#diagram-distances tspan.highlight { font-weight: bold; }
#diagram-distances tspan.q.highlight { fill: hsl( 90, 100%, 35%); }
#diagram-distances tspan.r.highlight { fill: hsl(200, 100%, 45%); }
#diagram-distances tspan.s.highlight { fill: hsl(300,  80%, 50%); }
#diagram-distances .highlight tspan.highlight { fill: black; }
#diagram-distances path.path { fill: none; stroke: hsl(60, 20%, 70%); stroke-width: 24px; stroke-opacity: 0.3; stroke-linecap: round; stroke-linejoin: round; }

#diagram-intersection .regionA polygon { fill:hsl(200,  40%, 80%); }
#diagram-intersection .regionB polygon { fill:hsl(300,  20%, 80%); }
#diagram-intersection .regionC polygon { fill:hsl(150,  20%, 80%); }
#diagram-intersection .center  polygon { fill:hsl(200,  50%, 70%); }

#diagram-field-of-view .shadow  polygon {  fill: hsl(60, 10%, 90%); }
#diagram-field-of-view .goal   polygon { fill: hsl(200,  50%, 70%); }
#diagram-field-of-view .goal.shadow   polygon { fill: hsl(200,  30%, 70%); }
#diagram-field-of-view .start  polygon { fill: hsl(60,  100%, 50%); }
#diagram-field-of-view .blocked polygon { fill: hsl(0,  20%, 70%); }
#diagram-field-of-view .blocked.goal polygon { fill: hsl(0,  20%, 70%); }

#diagram-movement-range .shadow polygon { fill: hsl(60, 10%, 90%); }
#diagram-movement-range .goal    polygon { fill: hsl(200,  50%, 70%); }
#diagram-movement-range .goal.shadow   polygon { fill: hsl(200,  30%, 70%); }
#diagram-movement-range .start  polygon { fill: hsl(60,  100%, 50%); }
#diagram-movement-range .blocked polygon { fill: hsl(0,  20%, 70%); }
#diagram-movement-range .shadow text { fill: hsl(60, 10%, 70%); }
#diagram-movement-range path.path { fill: none; stroke: hsl(60, 20%, 70%); stroke-width: 20px; stroke-opacity: 0.3; stroke-linecap: round; stroke-linejoin: round; }

#diagram-pathfinding .path    polygon { fill: hsl(200,  10%, 90%); }
#diagram-pathfinding .goal    polygon { fill: hsl(200,  50%, 70%); }
#diagram-pathfinding .start   polygon { fill: hsl(60,  100%, 50%); }
#diagram-pathfinding .blocked polygon { fill: hsl(0,  20%, 70%); }
#diagram-pathfinding path.path { fill: none; stroke: hsl(60, 20%, 50%); stroke-width: 4px; stroke-opacity: 0.5; stroke-linecap: round; stroke-linejoin: round; }

#diagram-map-storage-array .samerow rect,
#diagram-map-storage-shape .samerow polygon { fill: hsl(200, 20%, 90%); }
#diagram-map-storage-array .highlight rect,
#diagram-map-storage-shape .highlight polygon { fill: hsl(200, 50%, 80%); }
#diagram-map-storage-array .unused rect { fill: hsl(0, 0%, 80%); }

#diagram-wraparound .wrapped polygon { fill: hsl(300, 5%, 80%); }
#diagram-wraparound .wrapped.parity polygon { fill: hsl(120, 5%, 85%); }
#diagram-wraparound .wrapped.center polygon { fill: hsl(200, 10%, 70%); }
#diagram-wraparound .highlight polygon { fill: hsl(200, 50%, 80%); }
#diagram-wraparound .wrapped.highlight polygon { fill: hsl(200, 40%, 90%); }

circle.marker {
    fill: #a44;
}

line.marker, path.marker {
    stroke: #a44;
    stroke-width: 3px;
}

.grid-vertical path, .grid-horizontal path {
    fill: none;
    stroke-dasharray: 4, 3;
    stroke-width: 1px;
    stroke: hsl(0, 0%, 75%);
}

    </style></head><body class="gameprog width600"><header><h1 role="banner"><div class="title">Hexagonal Grids</div><div class="subheading">
      from <a href="http://www.redblobgames.com/">Red Blob Games</a></div></h1><nav role="navigation"><form action="https://www.google.com/search"><ul> <li class="nav"><a href="//www.redblobgames.com/">Home</a></li> <li class="nav"><a href="http://simblob.blogspot.com/">Blog</a></li> <li class="nav omit-if-narrow"><a href="http://pinboard.in/u:amitp/t:gamedev/">Links</a></li> <li class="nav omit-if-narrow"><a href="https://twitter.com/redblobgames">Twitter</a></li> <li class="nav"><a rel="me" href="http://www-cs-students.stanford.edu/~amitp/">About</a></li> <li class="nav omit-if-narrow"> <li class="nav omit-if-narrow"><input type="search" name="q" placeholder="Search" size="8"></li></ul><input type="hidden" name="hq" value="site:www.redblobgames.com OR site:theory.stanford.edu/~amitp/ OR site:www-cs-students.stanford.edu/~amitp/ OR site:amitp.blogspot.com OR site:simblob.blogspot.com"></form></nav></header><div class="main" role="main"><!-- Adapting the layout to wide vs narrow:

     Make a div.float-container to surround areas that should be wider.
     a. Any children inside this will be in the left column.
     b. Except if it's .float-right then it will be in the right column.
     
     For example layout A {diagram} B, the narrow version will be

         AAAAAAA
         diagram
         diagram
         BBBBBBB

     and the wide version will be

         AAAAAAA  diagram
         BBBBBBB  diagram
                  
  --><address>Mar 2013, updated in Mar 2015</address><div class="topic"><div class="float-container"><p><br> Hexagonal grids are used in some games but aren&#8217;t quite as straightforward or common as square grids. I&#8217;ve been <a href="http://www-cs-students.stanford.edu/~amitp/gameprog.html#hex">collecting hex grid resources</a> for nearly 20 years, and wrote this guide to the most elegant approaches that lead to the simplest code, largely based on the guides by <a href="http://www-cs-students.stanford.edu/~amitp/Articles/Hexagon2.html">Charles Fu</a> and <a href="http://www-cs-students.stanford.edu/~amitp/Articles/HexLOS.html">Clark Verbrugge</a>. I&#8217;ll describe the various ways to make hex grids, the relationships between them, as well as some common algorithms. Many parts of this page are interactive; choosing a type of grid will update diagrams, code, and text to match.</p><ol id="toc" class="float-right"><li><a href="#basics">Angles, size, spacing</a></li><li><a href="#coordinates">Coordinate systems</a></li><li><a href="#conversions">Conversions</a></li><li><a href="#neighbors">Neighbors</a></li><li><a href="#distances">Distances</a></li><li><a href="#line-drawing">Line drawing</a></li><li><a href="#range">Range</a></li><li><a href="#rotation">Rotation</a></li><li><a href="#rings">Rings</a></li><li><a href="#field-of-view">Field of view</a></li><li><a href="#hex-to-pixel">Hex to pixel</a></li><li><a href="#pixel-to-hex">Pixel to hex</a></li><li><a href="#rounding">Rounding</a></li><li><a href="#map-storage">Map storage</a></li><li><a href="#wraparound">Wraparound maps</a></li><li><a href="#pathfinding">Pathfinding</a></li><li><a href="#references">More reading</a></li></ol><p>The code samples on this page are written in pseudo-code; they&#8217;re meant to be easy to read and understand so that you can write your own implementation.</p></div><br style="clear:both"><noscript>This page includes interactive diagrams that require your browser to have SVG and Javascript enabled.</noscript></div><div class="h2banner"><h2 id="basics"><a class="anchor" href="#basics">#</a>Geometry</h2></div><div class="topic"><div class="float-container"><div class="float-right diagram"><svg id="hexagon-parts" width="260" height="220"></svg></div><div><p>Hexagons are 6-sided polygons. <em>Regular</em> hexagons have all the sides (edges) the same length. I&#8217;ll assume all the hexagons we&#8217;re working with here are regular. The typical orientations for hex grids are horizontal (<button class="pointy" onClick="orient(true)">pointy topped</button>) and vertical (<button class="flat" onClick="orient(false)">flat topped</button>).</p><p>Hexagons have 6 edges. Each edge is shared by 2 hexagons. Hexagons have 6 corners. Each corner is shared by 3 hexagons. For more about centers, edges, and corners, see <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/grids/">my article on grid parts</a> (squares, hexagons, and triangles).</p></div></div><h3>Angles</h3><div class="float-container"><div><p>In a regular hexagon the interior angles are 120°. There are six “wedges”, each an equilateral triangle with 60° angles inside. Corner <em>i</em> is at <code>(60° * i)<span class="orientation-adjust-degrees"></span></code>, <code>size</code> units away from the <code>center</code>. In code:</p><pre class="code">
function hex_corner(center, size, i):
    var angle_deg = 60 * i  <span class="orientation-adjust-code"></span>
    var angle_rad = PI / 180 * angle_deg
    return Point(center.x + size * cos(angle_rad),
                 center.y + size * sin(angle_rad))</pre></div><div class="float-right diagram"><svg id="hexagon-angles" width="260" height="260"></svg></div><div><p>To fill a hexagon, gather the polygon vertices at <code>hex_corner(…, 0)</code> through <code>hex_corner(…, 5)</code>. To draw a hexagon outline, use those vertices, and then draw a line back to <code>hex_corner(…, 0)</code>.</p><p>The difference between the two orientations is that x and y are swapped, and that causes the angles to change: <button class="flat" onClick="orient(false)">flat topped</button> angles are 0°, 60°, 120°, 180°, 240°, 300° and <button class="pointy" onClick="orient(true)">pointy topped</button> angles are 30°, 90°, 150°, 210°, 270°, 330°.</p></div></div><div class="float-container"><div><h3>Size and Spacing</h3><p>Next we want to put several hexagons together. In the <span class="orientation-vertical-horizontal">vertical</span> orientation, the <span class="orientation-width-height">width</span> of a hexagon is <code><span class="orientation-width-height">width</span> = size
          * 2</code>. The <span class="orientation-horizontal-vertical">horizontal</span> distance between adjacent hexes is <code><span class="orientation-horiz-vert">horiz</span> = <span class="orientation-width-height">width</span> * 3/4</code>.</p></div><div class="float-right diagram"><svg id="hexagon-spacing" width="500" height="330"></svg><br> Switch to <button class="flat" onClick="orient(false)">flat topped</button> or back to <button class="pointy" onClick="orient(true)">pointy topped</button> hexagons.</div><div><p>The <span class="orientation-height-width">height</span> of a hexagon is <code><span class="orientation-height-width">height</span> = sqrt(3)/2 *
          <span class="orientation-width-height">width</span></code>. The <span class="orientation-vertical-horizontal">vertical</span> distance between adjacent hexes is <code><span class="orientation-vert-horiz">vert</span> = <span class="orientation-height-width">height</span></code>.</p><p>Some games use pixel art for hexagons that does not match an exactly regular polygon. The angles and spacing formulas I describe in this section won&#8217;t match the sizes of your hexagons. The rest of the article, describing algorithms on hex grids, will work even if your hexagons are stretched or shrunk a bit.</p></div></div><br style="clear:both;height:0"></div><div class="h2banner"><h2 id="coordinates"><a class="anchor" href="#coordinates">#</a>Coordinate Systems</h2></div><div class="topic"><p>Now let&#8217;s assemble hexagons into a grid. With square grids, there&#8217;s one obvious way to do it. With hexagons, there are multiple approaches. I recommend using cube coordinates as the primary representation. Use either axial or offset coordinates for map storage, and displaying coordinates to the user.</p><h3>Offset coordinates</h3><p>The most common approach is to offset every other column or row. Columns are named <code>col</code> or <code>q</code>. Rows are named <code>row</code> or <code>r</code>. You can either offset the odd or the even column/rows, so the horizontal and vertical hexagons each have two variants.</p><div class="float-container"><div><div style="width:280px;display:inline-block;margin:5px"><svg id="grid-offset-odd-r" width="280" height="225"></svg><br> &#8220;odd-r&#8221; horizontal layout</div><div style="width:280px;display:inline-block;margin:5px"><svg id="grid-offset-even-r" width="280" height="225"></svg><br> &#8220;even-r&#8221; horizontal layout</div></div><div class="float-right"><div style="width:270px;display:inline-block;margin:5px"><svg id="grid-offset-odd-q" width="270" height="240"></svg><br> &#8220;odd-q&#8221; vertical layout</div><div style="width:270px;display:inline-block;margin:5px"><svg id="grid-offset-even-q" width="270" height="240"></svg><br> &#8220;even-q&#8221; vertical layout</div></div></div><h3>Cube coordinates</h3><div class="float-container"><div><p>Another way to look at hexagonal grids is to see that there are <em>three</em> primary axes, unlike the <em>two</em> we have for square grids. There&#8217;s an elegant symmetry with these.</p><p>Let&#8217;s take a cube grid and <strong>slice</strong> out a diagonal plane at <code><span class="x-axis">x</span> + <span class="y-axis">y</span> + <span class="z-axis">z</span> = 0</code>. This is a <em>weird</em> idea but it helps us make hex grid algorithms simpler. In particular, we can reuse standard operations from cartesian coordinates: adding coordinates, subtracting coordinates, multiplying or dividing by a scalar, and distances.</p><p>Notice the three primary axes on the cube grid, and how they correspond to six hex grid <em>diagonal</em> directions; the diagonal grid axes corresponds to a primary hex grid direction.</p><p>Because we already have algorithms for square and cube grids, using cube coordinates allows us to adapt those algorithms to hex grids. I will be using this system for most of the algorithms on the page. To use the algorithms with another coordinate system, I&#8217;ll <a href="#conversions">convert to cube coordinates</a>, run the algorithm, and convert back.</p></div><div class="float-right diagram"><svg id="cube-to-hex" width="375" height="375"></svg><br> Try: <button class="cube-to-hex-hexagons" onClick="diagram_cube_to_hex.to_hex()">switch to hexagons</button> and: <button class="cube-to-hex-cubes" onClick="diagram_cube_to_hex.to_cube()">switch back to cubes</button>.</div></div><div class="float-container"><p>Study how the cube coordinates work on the hex grid. Selecting the hexes will highlight the cube coordinates corresponding to the three axes.</p><div class="float-right diagram"><svg id="grid-cube" width="410" height="410"></svg><br> Switch to <button class="flat" onClick="orient(false)">flat topped</button> or back to <button class="pointy" onClick="orient(true)">pointy topped</button> hexagons.</div><ol><li>Each direction on the cube grid corresponds to a <em>line</em> on the hex grid. Try highlighting a hex with <code class="z-axis">z</code> at 0, 1, 2, 3 to see how these are related. The row is marked in blue. Try the same for <code class="x-axis">x</code> (green) and <code class="y-axis">y</code> (purple).</li><li>Each direction on the hex grid is a combination of <em>two</em> directions on the cube grid. For example, <span class="orientation-northwest-north">northwest</span> on the hex grid lies between the <code class="y-axis">+y</code> and <code class="z-axis">-z</code>, so every step <span class="orientation-northwest-north">northwest</span> involves adding 1 to <code class="y-axis">y</code> and subtracting 1 from <code class="z-axis">z</code>.</li></ol></div><p>The cube coordinates are a reasonable choice for a hex grid coordinate system. The constraint is that <code>x + y + z =
      0</code> so the algorithms must preserve that. The constraint also ensures that there&#8217;s a canonical coordinate for each hex.</p><p>There are <em>many</em> different valid cube hex coordinate systems. Some of them have constraints other than <code>x + y + z = 0</code>. I&#8217;ve shown only one of the many systems. You can also construct cube coordinates with <code>x-y, y-z, z-x</code>, and that has its own set of interesting properties, which I don&#8217;t explore here.</p><p>&#8220;But Amit!&#8221; you say, &#8220;I don&#8217;t want to store 3 numbers for coordinates. I don&#8217;t know how to store a map that way.&#8221;</p><div class="float-container"><div><h3>Axial coordinates</h3><p>The axial coordinate system, sometimes called “trapezoidal”, is built by taking two of the three coordinates from a cube coordinate system. Since we have a constraint such as <code>x + y + z = 0</code>, the third coordinate is redundant. Axial coordinates are useful for map storage and for displaying coordinates to the user. Like cube coordinates, you can use the standard <em>add, subtract, multiply, divide</em> operations from cartesian coordinates.</p></div><div class="float-right diagram"><svg id="grid-axial" width="410" height="410"></svg><br> Switch to <button class="flat" onClick="orient(false)">flat topped</button> or back to <button class="pointy" onClick="orient(true)">pointy topped</button> hexagons.</div><div><p>There are many cube coordinate systems, and many axial coordinate systems. I&#8217;m not going to show all of the combinations in this guide. I&#8217;m going to pick two variables, <code>q</code> for &#8220;column&#8221; and <code>r</code> as &#8220;row&#8221;. In the diagrams on this page, <code>q</code> is aligned with <code>x</code> and <code>r</code> is aligned with <code>z</code> but this alignment is arbitary, as you can rotate and flip the diagrams to make many different alignments.</p><p>The advantage of this system over offset grids is that the algorithms are cleaner. The disadvantage of this system is that storing a rectangular map is a little weird; see the <a href="#map-storage">map storage</a> section for ways to handle that. There are some algorithms that are even cleaner with cube coordinates, but for those, since we have the constraint <code>x + y + z = 0</code>, we can calculate the third implicit coordinate and use that for those algorithms. In my projects, I name the axes <code>q</code>, <code>r</code>, <code>s</code> so that I have the constraint <code>q + r + s = 0</code>, and then I can calculate <code>s = -q - r</code> when needed.</p></div></div><h3>Axes</h3><p>Offset coordinates are the first thing people think of, because they match the standard cartesian coordinates used with square grids. Unfortunately one of the two axes has to go “against the grain”, and ends up complicating things. The cube and axial systems go “with the grain” and have simpler algorithms, but slightly more complicated map storage. There&#8217;s also another system, called interlaced or doubled, that I haven&#8217;t explored here; some people say it&#8217;s easier to work with than cube/axial.</p><div class="diagram"><svg id="grid-comparison" width="500" height="200"></svg></div><p>The <em>axis</em> is the direction in which that coordinate increases. Perpendicular to the axis is a line where that coordinate stays constant. The grid diagrams above show the perpendicular line.</p></div><div class="h2banner"><h2 id="conversions"><a class="anchor" href="#conversions">#</a>Coordinate conversion</h2></div><div class="topic"><p>It is likely that you will use axial or offset coordinates in your project, but many algorithms are simpler to express in cube coordinates. Therefore you need to be able to convert back and forth.</p><p>Axial coordinates are closely connected to cube coordinates, so the conversion is easy:</p><pre>
# convert cube to axial
q = x
r = z

# convert axial to cube
x = q
z = r
y = -x-z</pre><p>In code, these two functions could be written like this:</p><pre>
function cube_to_hex(h): # axial
    var q = h.x
    var r = h.z
    return Hex(q, r)

function hex_to_cube(h): # axial
    var x = h.q
    var z = h.r
    var y = -x-z
    return Cube(x, y, z)</pre><p>Offset coordinates are only slightly tricky:</p><pre>
# convert cube to even-q offset
col = x
row = z + (x + (x&amp;1)) / 2

# convert even-q offset to cube
x = col
z = row - (col + (col&amp;1)) / 2
y = -x-z

# convert cube to odd-q offset
col = x
row = z + (x - (x&amp;1)) / 2

# convert odd-q offset to cube
x = col
z = row - (col - (col&amp;1)) / 2
y = -x-z

# convert cube to even-r offset
col = x + (z + (z&amp;1)) / 2
row = z

# convert even-r offset to cube
x = col - (row + (row&amp;1)) / 2
z = row
y = -x-z

# convert cube to odd-r offset
col = x + (z - (z&amp;1)) / 2
row = z

# convert odd-r offset to cube
x = col - (row - (row&amp;1)) / 2
z = row
y = -x-z</pre><p>Implementation note: I use <code>a&amp;1</code> (<a href="http://en.wikipedia.org/wiki/Bitwise_operation#AND">bitwise and</a>) instead of <code>a%2</code> (<a href="http://en.wikipedia.org/wiki/Modulo_operation">modulo</a>) to detect whether something is even (0) or odd (1). See a longer explanation on <a href="implementation.html#offset">my implementation notes page</a>.</p></div><div class="h2banner"><h2 id="neighbors"><a class="anchor" href="#neighbors">#</a>Neighbors</h2></div><div class="topic"><p>Given a hex, which 6 hexes are neighboring it? As you might expect, the answer is simplest with cube coordinates, still pretty simple with axial coordinates, and slightly trickier with offset coordinates. We might also want to calculate the 6 “diagonal” hexes.</p><div class="float-container"><div><h3>Cube coordinates</h3><p>Moving one space in hex coordinates involves changing one of the 3 cube coordinates by +1 and changing another one by -1 (the sum must remain 0). There are 3 possible coordinates to change by +1, and 2 remaining that could be changed by -1. This results in 6 possible changes. Each corresponds to one of the hexagonal directions. The simplest and fastest approach is to precompute the permutations and put them into a table of <code>Cube(dx, dy, dz)</code> at compile time:</p><pre id="neighbors-cube-code" class="neighbors-code">
var directions = <span class="table">[
   <span>Cube(+1, -1,  0)</span>, <span>Cube(+1,  0, -1)</span>, <span>Cube( 0, +1, -1)</span>,
   <span>Cube(-1, +1,  0)</span>, <span>Cube(-1,  0, +1)</span>, <span>Cube( 0, -1, +1)</span>
]</span>

function cube_direction(direction):
    return directions[direction]

function cube_neighbor(hex, direction):
    return cube_add(hex, cube_direction(direction))</pre></div><div class="float-right diagram"><svg id="neighbors-cube" class="neighbors" width="270" height="270"></svg></div></div><div class="float-container"><div><h3>Axial coordinates</h3><p>As before, we&#8217;ll use the cube system as a starting point. Take the table of <code>Cube(dx, dy, dz)</code> and convert into a table of <code>Hex(dq, dr)</code>:</p><pre id="neighbors-axial-code" class="neighbors-code">
var directions = <span class="table">[
   <span></span>, <span></span>, <span></span>,
   <span></span>, <span></span>, <span></span>
]</span>

function hex_direction(direction):
    return directions[direction]

function hex_neighbor(hex, direction):
    var dir = hex_direction(direction)
    return Hex(hex.q + dir.q, hex.r + dir.r)</pre></div><div class="float-right diagram"><svg id="neighbors-axial" class="neighbors" width="270" height="270"></svg></div></div><h3>Offset coordinates</h3><p>With offset coordinates, the change depends on where in the grid we are. If we&#8217;re on an offset column/row then the rule is different than if we&#8217;re on a non-offset column/row.</p><p>As above, we&#8217;ll build a table of the numbers we need to add to <code>col</code> and <code>row</code>. However this time there will be two arrays, one for odd columns/rows and one for even columns/rows. Look at <code>(1,1)</code> on the grid map above and see how <code>col</code> and <code>row</code> change as you move in each of the six directions. Then do this again for <code>(2,2)</code>. The tables and code are different for each of the four offset grid types, so <strong>pick a grid type</strong> to see the corresponding code.</p><div class="float-container"><pre id="neighbors-offset-code" class="column neighbors-code">
var directions = <span class="table">[
   [ <span></span>, <span></span>, <span></span>,
     <span></span>, <span></span>, <span></span> ],
   [ <span></span>, <span></span>, <span></span>,
     <span></span>, <span></span>, <span></span> ]
]</span>

function offset_neighbor(hex, direction):
    var parity = hex.<span class="parity"></span> &amp; 1
    var dir = directions[parity][direction]
    return Hex(hex.col + dir.col, hex.row + dir.row)</pre><div class="float-right diagram"><strong>Pick a grid type:</strong>  <label><input type="radio" id="neighbors-offset-odd-r" name="neighbors-offset-choice"> odd-r </label><label><input type="radio" id="neighbors-offset-even-r" name="neighbors-offset-choice"> even-r </label><label><input type="radio" id="neighbors-offset-odd-q" name="neighbors-offset-choice"> odd-q </label><label><input type="radio" id="neighbors-offset-even-q" name="neighbors-offset-choice"> even-q </label><br><svg id="neighbors-offset" class="neighbors" width="400" height="175"></svg></div></div><p>Using the above lookup tables is the easiest way to to calculate neighbors. It&#8217;s also possible to <a href="derive-hex-neighbor-formula.html">derive these numbers</a>, for those of you who are curious.</p><h3>Diagonals</h3><div class="float-container"><div><p>Moving to a “diagonal” space in hex coordinates changes one of the 3 cube coordinates by ±2 and the other two by ∓1 (the sum must remain 0).</p><pre>
var diagonals = <span class="table">[
   <span>Cube(+2, -1, -1)</span>, <span>Cube(+1, +1, -2)</span>, <span>Cube(-1, +2, -1)</span>, 
   <span>Cube(-2, +1, +1)</span>, <span>Cube(-1, -1, +2)</span>, <span>Cube(+1, -2, +1)</span>
]</span>

function cube_diagonal_neighbor(hex, direction):
    return cube_add(hex, diagonals[direction])</pre><p>As before, you can convert these into axial by dropping one of the three coordinates, or convert to offset by precalculating the results.</p></div><div class="float-right diagram"><svg id="neighbors-diagonal" width="305" height="305"></svg></div></div></div><div class="h2banner"><h2 id="distances"><a class="anchor" href="#distances">#</a>Distances</h2></div><div class="topic"><h3>Cube coordinates</h3><div class="float-container"><div><p>In the cube coordinate system, each hexagon is a cube in 3d space. Adjacent hexagons are distance 1 apart in the hex grid but distance 2 apart in the cube grid. This makes distances simple. In a square grid, Manhattan distances are <code>abs(dx) + abs(dy)</code>. In a cube grid, Manhattan distances are <code>abs(dx) + abs(dy) + abs(dz)</code>. The distance on a hex grid is half that:</p><pre>
function cube_distance(a, b):
    return (abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z)) / 2</pre><p>An equivalent way to write this is by noting that one of the three coordinates must be the sum of the other two, then picking that one as the distance. You may prefer the “divide by two” form above, or the “max” form here, but they give the same result:</p><pre>
function cube_distance(a, b):
    return max(abs(a.x - b.x), abs(a.y - b.y), abs(a.z - b.z))</pre><p>In the diagram, the max is highlighted. Also notice that each color indicates one of the 6 “diagonal” directions.<!-- You
          can also use the max of <code>abs(dx-dy), abs(dy-dz),
          abs(dz-dx)</code> to figure out which of the 6 “wedges” a hex is in. --><!-- this is worth a diagram! --></p></div><div class="float-right diagram"><svg id="diagram-distances" width="600" height="570"></svg></div></div><h3>Axial coordinates</h3><p>In the axial system, the third coordinate is implicit. Let&#8217;s <a href="#conversions">convert</a> axial to cube to calculate distance:</p><pre>
function hex_distance(a, b):
    var ac = hex_to_cube(a)
    var bc = hex_to_cube(b)
    return cube_distance(ac, bc)</pre><p>If your compiler inlines <code>hex_to_cube</code> and <code>cube_distance</code>, it will generate this code:</p><pre>
function hex_distance(a, b):
    return (abs(a.q - b.q) 
          + abs(a.q + a.r - b.q - b.r)
          + abs(a.r - b.r)) / 2</pre><p>There are lots of different ways to write hex distance in axial coordinates, but no matter which way you write it, <em>axial hex distance is derived from the Mahattan distance on cubes</em>. For example, the “difference of differences” described <a href="http://3dmdesign.com/development/hexmap-coordinates-the-easy-way">here</a> results from writing <code>a.q + a.r - b.q - b.r</code> as <code>a.q - b.q + a.r - b.r</code>, and using “max” form instead of the “divide by two” form of <code>cube_distance</code>. They&#8217;re all equivalent once you see the connection to cube coordinates.</p><h3>Offset coordinates</h3><p>As with axial coordinates, we&#8217;ll <a href="#conversions">convert</a> offset coordinates to cube coordinates, then use cube distance.</p><pre>
function offset_distance(a, b):
    var ac = offset_to_cube(a)
    var bc = offset_to_cube(b)
    return cube_distance(ac, bc)</pre><p>We&#8217;ll use the same pattern for many of the algorithms: convert hex to cube, run the cube version of the algorithm, and convert any cube results back to hex coordinates (whether axial or offset).</p></div><div class="h2banner"><h2 id="line-drawing"><a class="anchor" href="#line-drawing">#</a>Line drawing</h2></div><div class="topic"><div class="float-container"><p>How do we draw a line from one hex to another? I use <a href="/grids/line-drawing.html">linear interpolation for line drawing</a>. Evenly <em>sample</em> the line at <code>N+1</code> points, and figure out which hexes those samples are in.</p><div class="float-right diagram"><svg id="diagram-line" width="600" height="570"></svg></div><div><ol><li>First we calculate <code>N</code> to be the <a href="#distances">hex distance</a> between the endpoints.</li><li>Then evenly sample <code>N+1</code> points between point <code>A</code> and point <code>B</code>. Using linear interpolation, each point will be <code>A + (B - A) * 1.0/N * i</code>, for values of <code>i</code> from <code>0</code> to <code>N</code>, inclusive. In the diagram these sample points are the dark blue dots. This results in floating point coordinates.</li><li>Convert each sample point (float) back into a hex (int). The algorithm is called <a href="#rounding">cube_round</a>.</li></ol></div></div><p>Putting these together to draw a line from <code>A</code> to <code>B</code>:</p><pre>
function lerp(a, b, t): // for floats
    return a + (b - a) * t

function cube_lerp(a, b, t): // for hexes
    return Cube(lerp(a.x, b.x, t), 
                lerp(a.y, b.y, t),
                lerp(a.z, b.z, t))

<!--
# Adjust one endpoint to break ties, make lines look better
ɛ = 1e-6
a.x += ɛ; a.y += ɛ; a.z -= 2*ɛ;
-->function cube_linedraw(a, b):
    var N = cube_distance(a, b)
    var results = []
    for each 0 ≤ i ≤ N:
        results.append(cube_round(cube_lerp(a, b, 1.0/N * i)))
    return results</pre><!--
     (Note: originally I had recommended using
              <code>N = max(abs(dx - dy), abs(dy - dz), abs(dz -
              dx))</code> but Theodore Lief Gannon ‏(<a
              href="https://twitter.com/dour">@dour</a>) pointed out
              that the distance works better.)
              --><p>More notes:</p><ul><li>There are times when <code>cube_lerp</code> will return a point that&#8217;s just on the edge between two hexes. Then <code>cube_round</code> will push it one way or the other. The <em>lines will look better</em> if it&#8217;s always pushed in the same direction. You can do this by adding an &#8220;epsilon&#8221; hex <code>Cube(1e-6, 1e-6, -2e-6)</code> to one or both of the endpoints before starting the loop. This will &#8220;nudge&#8221; the line in one direction to avoid landing on edge boundaries.</li><li>The <a href="http://en.wikipedia.org/wiki/Digital_differential_analyzer_(graphics_algorithm)">DDA Algorithm</a> on square grids sets <code>N</code> to the max of the distance along each axis. We do the same in cube space, which happens to be the same as the hex grid distance.</li><li>The <code>cube_lerp</code> function needs to return a cube with float coordinates. If you&#8217;re working in a statically typed language, you won&#8217;t be able to use the <code>Cube</code> type but instead could define <code>FloatCube</code>, or inline the function into the line drawing code if you want to avoid defining another type.</li><li>You can optimize the code by inlining <code>cube_lerp</code>, and then calculating <code>B.x-A.x</code>, <code>B.x-A.y</code>, and <code>1.0/N</code> outside the loop. Multiplication can be turned into repeated addition. You&#8217;ll end up with something like the DDA algorithm.</li><li>I use axial or cube coordinates for line drawing, but if you want something for offset coordinates, take a look at <a href="http://zvold.blogspot.com/2010/02/line-of-sight-on-hexagonal-grid.html">this article</a>.</li><li>There are many variants of line drawing. Sometimes you&#8217;ll want <a href="http://stackoverflow.com/questions/3233522/elegant-clean-special-case-straight-line-grid-traversal-algorithm">&#8220;super cover&#8221;</a>. Someone sent me hex super cover line drawing code but I haven&#8217;t studied it yet.</li></ul></div><div class="h2banner"><h2 id="range"><a class="anchor" href="#range">#</a>Movement Range</h2></div><div class="topic"><h3>Coordinate range</h3><div class="float-container"><div><p>Given a hex <code>center</code> and a range N, which hexes are within N steps from it?</p><p>We can work backwards from the <a href="#distances">hex distance</a> formula, <code>distance = max(abs(dx), abs(dy), abs(dz))</code>. To find all hexes within N steps, we need <code>max(abs(dx), abs(dy), abs(dz)) ≤ N</code>. This means we need all three of: <code>abs(dx) ≤ N</code> and <code>abs(dy) ≤ N</code> and <code>abs(dz) ≤ N</code>. Removing absolute value, we get <code class="x-axis">-N ≤ dx ≤ N</code> and <code class="y-axis">-N ≤ dy ≤ N</code> and <code class="z-axis">-N ≤ dz ≤ N</code>. In code it&#8217;s a nested loop:</p><pre>
var results = []
for each -N ≤ dx ≤ N:
    for each -N ≤ dy ≤ N:
        for each -N ≤ dz ≤ N:
            if dx + dy + dz = 0:
                results.append(cube_add(center, Cube(dx, dy, dz)))</pre><p>This loop will work but it&#8217;s somewhat inefficient. Of all the values of <code>dz</code> we loop over, only one of them actually satisfies the <code>dx + dy + dz = 0</code> constraint on cubes. Instead, let&#8217;s directly calculate the value of <code>dz</code> that satisfies the constraint:</p><pre>
var results = []
for each -N ≤ dx ≤ N:
    for each max(-N, -dx-N) ≤ dy ≤ min(N, -dx+N):
        var dz = -dx-dy
        results.append(cube_add(center, Cube(dx, dy, dz)))</pre><p>This loop iterates over exactly the needed coordinates. In the diagram, each range is a pair of lines. Each line is an inequality. We pick all the hexes that satisfy all six inequalities.</p></div><div class="float-right diagram"><svg id="diagram-hex-range" width="500" height="470"></svg></div></div><h3>Intersecting ranges</h3><div class="float-container"><div><p>If you need to find hexes that are in more than one range, you can intersect the ranges before generating a list of hexes.</p><p>You can either think of this problem algebraically or geometrically. Algebraically, each region is expressed as inequality constraints of the form <code>-N ≤ dx ≤ N</code>, and we&#8217;re going to solve for the intersection of those constraints. Geometrically, each region is a cube in 3D space, and we&#8217;re going to intersect two cubes in 3D space to form a <a href="http://en.wikipedia.org/wiki/Cuboid">cuboid</a> in 3D space, then project back to the x + y + z = 0 plane to get hexes. I&#8217;m going to solve it algebraically:</p><p>First, we rewrite constraint <code>-N ≤ dx ≤ N</code> into a more general form, <code>x<sub>min</sub> ≤ x ≤
          x<sub>max</sub></code>, and set <code>x<sub>min</sub> = center.x
          - N</code> and <code>x<sub>max</sub> = center.x + N</code>. We&#8217;ll do the same for <code>y</code> and <code>z</code>, and end up with this generalization of the code from the previous section:</p><pre>
var results = []
for each x<sub>min</sub> ≤ x ≤ x<sub>max</sub>:
    for each max(y<sub>min</sub>, -x-z<sub>max</sub>) ≤ y ≤ min(y<sub>max</sub>, -x-z<sub>min</sub>):
        var z = -x-y
        results.append(Cube(x, y, z))</pre><p>The intersection of two ranges <code>a ≤ x ≤ b</code> and <code>c ≤ x ≤ d</code> is <code>max(a, c) ≤ x ≤ min(b,
          d)</code>. Since a hex region is expressed as ranges over x, y, z, we can separately intersect each of the x, y, z ranges then use the nested loop to generate a list of hexes in the intersection. For one hex region we set <code>x<sub>min</sub> = H.x - N</code> and <code>x<sub>max</sub> = H.x + N</code> and likewise for <code>y</code> and <code>z</code>. For intersecting two hex regions we set <code>x<sub>min</sub> = max(H<sub>1</sub>.x -
          N, H<sub>2</sub>.x - N)</code> and <code>x<sub>max</sub> =
          min(H<sub>1</sub>.x + N, H<sub>2</sub>.x + N), and likewise
          for <code>y</code> and <code>z</code>. The same pattern
          works for intersecting three or more regions.</code></p></div><div class="float-right diagram"><svg id="diagram-intersection" width="500" height="470"></svg></div></div><h3>Obstacles</h3><div class="float-container"><div><p>If there are obstacles, the simplest thing to do is a distance-limited flood fill (breadth first search). In this diagram, the limit is set to <span class="movement-range"></span> moves. In the code, <code>fringes[k]</code> is an array of all hexes that can be reached in <code>k</code> steps. Each time through the main loop, we expand level <code>k-1</code> into level <code>k</code>.</p><pre>
function cube_reachable(start, movement):
    var visited = set()
    add start to visited
    var fringes = []
    fringes.append([start])

    for each 1 &lt; k ≤ movement:
        fringes.append([])
        for each cube in fringes[k-1]:
            for each 0 ≤ dir &lt; 6:
                var neighbor = cube_neighbor(cube, dir)
                if neighbor not in visited, not blocked:
                    add neighbor to visited
                    fringes[k].append(neighbor)

    return visited</pre></div><div class="float-right diagram"><svg id="diagram-movement-range" width="500" height="470"></svg></div><p>Limit <code>movement = <span class="movement-range"></span></code> : <input id="limit-movement-range" type="range" min="0" max="20" value="4" style="width:50%"></p></div></div><div class="h2banner"><h2 id="rotation"><a class="anchor" href="#rotation">#</a>Rotation</h2></div><div class="topic"><div class="float-container"><div><p>Given a hex vector (difference between one hex and another), we might want to rotate it to point to a different hex. This is simple with cube coordinates if we stick with rotations of 1/6th of a circle.</p><p>A rotation 60° right shoves each coordinate one slot to the right:</p><pre>
        [ x,  y,  z]
to  [-z, -x, -y]</pre><p>A rotation 60° left shoves each coordinate one slot to the left:</p><pre>
      [ x,  y,  z]
to        [-y, -z, -x]</pre></div><div class="float-right diagram"><svg id="diagram-rotation" width="600" height="570"></svg></div><div><p>As you play with diagram, notice that each 60° rotation <em>flips</em> the signs and also physically “rotates” the coordinates. After a 120° rotation the signs are flipped back to where they were. A 180° rotation flips the signs but the coordinates have rotated back to where they originally were.</p><p>Here&#8217;s the full recipe for rotating a position P around a center position C to result in a new position R:</p><ol><li><a href="#conversions">Convert</a> positions P and C to cube coordinates.</li><li>Calculate a vector by subtracting the center: <code>P_from_C = P - C = Cube(P.x - C.x, P.y - C.y, P.z - C.z)</code>.</li><li>Rotate the vector <code>P_from_C</code> as described above, and call the resulting vector <code>R_from_C</code>.</li><li>Convert the vector back to a position by adding the center: <code>R = R_from_C + C = Cube(R_from_C.x + C.x, R_from_C.y + C.y, R_from_C.z + C.z)</code>.</li><li><a href="#conversions">Convert</a> the cube position R back to to your preferred coordinate system.</li></ol><p>It&#8217;s several conversion steps but each step is simple. You can shortcut some of these steps by defining rotation directly on axial coordinates, but hex vectors don&#8217;t work for offset coordinates and I don&#8217;t know a shortcut for offset coordinates. Also see <a href="http://gamedev.stackexchange.com/questions/15237/how-do-i-rotate-a-structure-of-hexagonal-tiles-on-a-hexagonal-grid/">this stackexchange discussion</a> for other ways to calculate rotation.</p></div></div></div><div class="h2banner"><h2 id="rings"><a class="anchor" href="#rings">#</a>Rings</h2></div><div class="topic"><div class="float-container"><div><h3>Single ring</h3><p>To find out whether a given hex is on a ring of a given <code>radius</code>, calculate the distance from that hex to the center and see if it&#8217;s <code>radius</code>. To get a list of all such hexes, take <code>radius</code> steps away from the center, then follow the rotated vectors in a path around the ring.</p><pre>
function cube_ring(center, radius):
    var results = []
    # this code doesn't work for radius == 0; can you see why?
    var cube = cube_add(center, 
                        cube_scale(cube_direction(4), radius))
    for each 0 ≤ i &lt; 6:
        for each 0 ≤ j &lt; radius:
            results.append(cube)
            cube = cube_neighbor(cube, i)
    return results</pre><p>In this code, <code>cube</code> starts out on the ring, shown by the large arrow from the center to the corner in the diagram. I chose corner 4 to start with because it lines up the way my direction numbers work but you may need a different starting corner. At each step of the inner loop, <code>cube</code> moves one hex along the ring. After <code>6 * radius</code> steps it ends up back where it started.</p></div><div class="float-right diagram"><svg id="diagram-rings" width="500" height="470"></svg></div></div><div class="float-container"><div><h3>Spiral rings</h3><p>Traversing the rings one by one in a spiral pattern, we can fill in the interior:</p><pre>
function cube_spiral(center, radius):
    var results = [center]
    for each 1 ≤ k ≤ radius:
        results = results + cube_ring(center, k)
    return results</pre></div><div class="float-right diagram"><svg id="diagram-spiral" width="500" height="470"></svg></div><p>The area of the larger hexagon will be the sum of the circumferences, plus 1 for the center; use <a href="https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF">this formula</a> to help you calculate the area.</p><p>Visiting the hexes this way can also be used to calculate <a href="#range">movement range</a>.</p></div></div><div class="h2banner"><h2 id="field-of-view"><a class="anchor" href="#field-of-view">#</a>Field of view</h2></div><div class="topic"><div class="float-container"><div><p>Given a location and a distance, what is visible from that location, not blocked by obstacles? The simplest way to do this is to draw a line to every hex that&#8217;s in range. If the line doesn&#8217;t hit any walls, then you can see the hex. Mouse over a hex to see the line being drawn to that hex, and which walls it hits.</p><p>This algorithm can be slow for large areas but it&#8217;s so easy to implement that it&#8217;s what I recommend starting with.</p></div><div class="float-right diagram"><svg id="diagram-field-of-view" width="600" height="570"></svg></div></div><!--
    <p>
      Another algorithm would be to move outwards from the center
      hex. Keep a set of ranges of angles that are in shadow. If you
      encounter a hex that's within one of the ranges, then it's not
      visible. If you encounter a hex that's an obstacle, you generate
      a new angle range and union it with the existing set. I think <a
      href="http://en.wikipedia.org/wiki/Interval_tree">interval
      trees</a> might be useful for this. <s>{{ sketch is: for each
      hex in the spiral ring traversal { calculate min/max angle of
      the hex; if range is entirely contained within shadow range set,
      skip; otherwise if it's an obstacle, add range to shadow range
      set; otherwise hex is visible } but dealing with the angle
      ranges crossing 0 deg will be an added complication }}</s>
    </p>
    --><p>There are many different ways to define what&#8217;s &#8220;visible&#8221;. Do you want to be able to see the center of the other hex from the center of the starting hex? Do you want to see any part of the other hex from the center of the starting point? Maybe any part of the other hex from any part of the starting point? Are there obstacles that occupy less than a complete hex? Field of view turns out to be trickier and more varied than it might seem at first. Start with the simplest algorithm, but expect that it may not compute exactly the answer you want for your project. <span id="field-of-view-illogical-results">There are even situations where the simple algorithm produces results that are illogical.</span></p><p><a href="http://www-cs-students.stanford.edu/~amitp/Articles/HexLOS.html">Clark Verbrugge&#8217;s guide</a> describes a “start at center and move outwards” algorithm to calculate field of view. Also see the <a href="https://github.com/jbochi/duelo">Duelo</a> project, which has an <a href="https://s3.amazonaws.com/jbochi/layout.html">an online demo of directional field of view</a> and code on Github. Also see <a href="/articles/visibility/">my article on 2d visibility calculation</a> for an algorithm that works on polygons, including hexagons. For grids, the roguelike community has a nice set of algorithms for square grids (see <a href="http://www.adammil.net/blog/v125_Roguelike_Vision_Algorithms.html">this</a> and <a href="http://www.roguebasin.com/index.php?title=Pre-Computed_Visibility_Tries">this</a> and <a href="http://www.roguebasin.com/index.php?title=Field_of_Vision">this</a>); some of them might be adapted for hex grids.</p></div><div class="h2banner"><h2 id="hex-to-pixel"><a class="anchor" href="#hex-to-pixel">#</a>Hex to pixel</h2></div><div class="topic"><div class="float-container"><p>For hex to pixel, it&#8217;s useful to review the <a href="#basics">size and spacing diagram</a> at the top of the page. For axial coordinates, the way to think about hex to pixel conversion is to look at the <em>basis vectors</em>. In the diagram, the arrow A→Q is the q basis vector and A→R is the r basis vector. The pixel coordinate is <code>q_basis * q + r_basis * r</code>. For example, B at (1, 1) is the sum of the q and r basis vectors.</p><div class="float-right diagram"><svg id="diagram-hex-to-pixel" width="300" height="180"></svg></div></div><p>If you have a matrix library, this is a simple matrix multiplication; however I&#8217;ll write the code out without matrices here. For the <code>x = q, z = r</code> axial grid I use in this guide, the conversion is:</p><pre id="hex-to-pixel-code-axial">
function hex_to_pixel(hex):
    <span>x = size * sqrt(3) * (hex.q + hex.r/2)
    y = size * 3/2 * hex.r</span><span>x = size * 3/2 * hex.q
    y = size * sqrt(3) * (hex.r + hex.q/2)</span>
    return Point(x, y)</pre><div class="diagram">Axial coordinates: <label><input type="radio" id="hex-to-pixel-axial-flat" name="hex-to-pixel-axial">flat top</label> or <label><input type="radio" id="hex-to-pixel-axial-pointy" name="hex-to-pixel-axial">pointy top</label></div><p>The matrix approach will come in handy later when we want to <a href="#pixel-to-hex">convert pixel coordinates back to hex coordinates</a>. All we will have to do is invert the matrix. For cube coordinates, you can either use cube basis vectors (x, y, z), or you can convert to axial first and then use axial basis vectors (q, r).</p><p>For offset coordinates, we need to offset either the column or row number (it will no longer be an integer). After that you can use a q and r basis vector, aligned with the x and y axes:</p><pre id="hex-to-pixel-code-offset">
function offset_to_pixel(hex):
    <span>x = size * sqrt(3) * (hex.col <b>+</b> 0.5 * (hex.row&amp;1))
    y = size * 3/2 * hex.row</span><span>x = size * sqrt(3) * (hex.col <b>-</b> 0.5 * (hex.row&amp;1))
    y = size * 3/2 * hex.row</span><span>x = size * 3/2 * hex.col
    y = size * sqrt(3) * (hex.row <b>+</b> 0.5 * (hex.col&amp;1))</span><span>x = size * 3/2 * hex.col
    y = size * sqrt(3) * (hex.row <b>-</b> 0.5 * (hex.col&amp;1))</span>
    return Point(x, y)</pre><div class="diagram">Offset coordinates:  <label><input type="radio" id="hex-to-pixel-offset-oddR" name="hex-to-pixel-offset"> odd-r </label><label><input type="radio" id="hex-to-pixel-offset-evenR" name="hex-to-pixel-offset"> even-r </label><label><input type="radio" id="hex-to-pixel-offset-oddQ" name="hex-to-pixel-offset"> odd-q </label><label><input type="radio" id="hex-to-pixel-offset-evenQ" name="hex-to-pixel-offset"> even-q </label></div><p>Unfortunately offset coordinates don&#8217;t have basis vectors that we can use with a matrix. This is one reason <a href="#pixel-to-hex">pixel-to-hex</a> conversions are harder with offset coordinates.</p><p>Another approach is to convert the offset coordinates into cube/axial coordinates, then use the cube/axial to pixel conversion. By inlining the conversion code then optimizing, it will end up being the same as above.</p></div><div class="h2banner"><h2 id="pixel-to-hex"><a class="anchor" href="#pixel-to-hex">#</a>Pixel to Hex</h2></div><div class="topic"><p>One of the most common questions is, how do I take a pixel location (such as a mouse click) and convert it into a hex grid coordinate? I&#8217;ll show how to do this for axial or cube coordinates. For offset coordinates, the simplest thing to do is to convert the cube to offset at the end.</p><div class="float-right diagram"><svg id="diagram-pixel-to-hex" width="600" height="265"></svg></div><ol><li>First we <em>invert</em> the hex to pixel conversion. This will give us a <em>fractional</em> hex coordinate, shown as a small blue circle in the diagram.</li><li>Then we find the hex containing the fractional hex coordinate, shown as the highlighted hex in the diagram.</li></ol><div class="float-container"><div><p>To convert from <a href="#hex-to-pixel">hex coordinates to pixel coordinates</a>, we multiplied <code>q, r</code> by <em>basis vectors</em> to get <code>x, y</code>. You can think of this as a matrix multiply. Here&#8217;s the matrix for “pointy top” hexes:</p><pre style="line-height:1.0;background:transparent;border:none;resize:none">
⎡x⎤            ⎡ sqrt(3)   sqrt(3)/2 ⎤   ⎡q⎤
⎢ ⎥  =  size × ⎢                     ⎥ × ⎢ ⎥
⎣y⎦            ⎣  0            3/2   ⎦   ⎣r⎦</pre><p>Converting from pixel coordinates back to hex coordinates is straightforward. We can <a href="http://www.wolframalpha.com/input/?i=inv+%7B%7Bsqrt%283%29%2C+sqrt%283%29%2F2%7D%2C+%7B0%2C+3%2F2%7D%7D">invert the matrix</a>:</p><pre style="line-height:1.0;background:transparent;border:none;resize:none">
⎡q⎤     ⎡ sqrt(3)/3     -1/3 ⎤   ⎡x⎤
⎢ ⎥  =  ⎢                    ⎥ × ⎢ ⎥ ÷ size
⎣r⎦     ⎣     0          2/3 ⎦   ⎣y⎦</pre><p>This calculation will give us fractional axial coordinates (floats) for <code>q</code> and <code>r</code>. The <a href="#rounding">hex_round()</a> function will convert the fractional axial coordinates into integer axial hex coordinates.</p><p>Here&#8217;s the code for “pointy top” axial hexes:</p><pre>
function pixel_to_hex(x, y):
    q = (x * sqrt(3)/3 - y / 3) / size
    r = y * 2/3 / size
    return hex_round(Hex(q, r))</pre><p>And here&#8217;s the code for “flat top” axial hexes:</p><pre>
function pixel_to_hex(x, y):
    q = x * 2/3 / size
    r = (-x / 3 + sqrt(3)/3 * y) / size
    return hex_round(Hex(q, r))</pre><p>That&#8217;s three lines of code to convert a pixel location into an axial hex coordinate. If you use offset coordinates, use <code>return cube_to_hex(cube_round(Cube(q, -q-r, r)))</code>.</p></div></div><p>There are many other ways to convert pixel to hex; see <a href="more-pixel-to-hex.html">this page</a> for the ones I know of.</p><!--
    <p>
      Note that the above conversions assume for hex <code>q=0,
      r=0</code> is <em>centered</em> at <code>x=0.0, y=0.0</code>. If
      you want to center that hex elsewhere, subtract the desired
      center from the <code>x, y</code> before converting.
    </p>
    --></div><div class="h2banner"><h2 id="rounding"><a class="anchor" href="#rounding">#</a>Rounding to nearest hex</h2></div><div class="topic"><p>Sometimes we'll end up with a <em>floating-point</em> cube coordinate <code>(x, y, z)</code>, and we&#8217;ll want to know which hex it should be in. This comes up in <a href="#line-drawing">line drawing</a> and <a href="#pixel-to-hex">pixel to hex</a>. Converting a floating point value to an integer value is called <em>rounding</em> so I call this algorithm <code>cube_round</code>.</p><p>With cube coordinates, <code>x + y + z = 0</code>, even with floating point cube coordinates. So let&#8217;s round each component to the nearest integer, <code>(rx, ry, rz)</code>. However, although <code>x + y + z = 0</code>, after rounding we do <em>not</em> have a guarantee that <code>rx + ry + rz = 0</code>. So we <em>reset</em> the component with the largest change back to what the constraint <code>rx + ry + rz = 0</code> requires. For example, if the y-change <code>abs(ry-y)</code> is larger than <code>abs(rx-x)</code> and <code>abs(rz-z)</code>, then we reset <code>ry = -rx-rz</code>. This guarantees that <code>rx + ry + rz = 0</code>. Here&#8217;s the algorithm:</p><pre>
function cube_round(h):
    var rx = round(h.x)
    var ry = round(h.y)
    var rz = round(h.z)

    var x_diff = abs(rx - h.x)
    var y_diff = abs(ry - h.y)
    var z_diff = abs(rz - h.z)

    if x_diff &gt; y_diff and x_diff &gt; z_diff:
        rx = -ry-rz
    else if y_diff &gt; z_diff:
        ry = -rx-rz
    else:
        rz = -rx-ry

    return Cube(rx, ry, rz)</pre><p>For non-cube coordinates, the simplest thing to do is to <a href="#conversions">convert to cube coordinates</a>, use the rounding algorithm, then convert back:</p><pre>
function hex_round(h):
    return cube_to_hex(cube_round(hex_to_cube(h)))</pre><p>Implementation note: <code>cube_round</code> and <code>hex_round</code> take <em>float</em> coordinates instead of <em>int</em> coordinates. If you&#8217;ve written a Cube and Hex class, they&#8217;ll work fine in dynamically languages where you can pass in floats instead of ints, and they&#8217;ll also work fine in statically typed languages with a unified number type. However, in most statically typed languages, you&#8217;ll need a separate class/struct type for float coordinates, and <code>cube_round</code> will have type <code>FloatCube → Cube</code>. If you also need <code>hex_round</code>, it will be <code>FloatHex → Hex</code>, using helper function <code>floatcube_to_floathex</code> instead of <code>cube_to_hex</code>. In languages with parameterized types (C++, Haskell, etc.) you might define <code>Cube&lt;T&gt;</code> where <code>T</code> is either <code>int</code> or <code>float</code>. Alternatively, you could write <code>cube_round</code> to take three floats as inputs instead of defining a new type just for this function.</p><!--
    <p>
      This algorithm is based on <a
      href="http://www-cs-students.stanford.edu/~amitp/Articles/Hexagon2.html">Charles
      Fu's article</a>. His code contains the additional optimization
      that if <code>rx + ry + rz = 0</code> there's no need to
      look at the error values and reset the largest component.
    </p>
    --></div><div class="h2banner"><h2 id="map-storage"><a class="anchor" href="#map-storage">#</a>Map storage in axial coordinates</h2></div><div class="topic"><p>One of the common complaints about the axial coordinate system is that it leads to wasted space when using a rectangular map; that's one reason to favor an offset coordinate system. However all the hex coordinate systems lead to wasted space when using a triangular or hexagonal map. We can use the same strategies for storing all of them.</p><div class="float-container"><div class="diagram"><svg id="diagram-map-storage-shape" width="600" height="300"></svg><br> Shape: <label><input type="radio" id="map-storage-rectangle" name="map-storage-shape">rectangle</label><label><input type="radio" id="map-storage-triangle" name="map-storage-shape">triangle</label><label><input type="radio" id="map-storage-hexagon" name="map-storage-shape">hexagon</label><label><input type="radio" id="map-storage-rhombus" name="map-storage-shape">rhombus</label></div><div class="float-right diagram"><svg id="diagram-map-storage-array" width="400" height="300"></svg><br><span id="map-storage-formula"></span></div></div><p>Notice in the diagram that the wasted space is on the left and right sides of each row (except for rhombus maps) This gives us three strategies for storing the map:</p><ol><li><strong>Ignore</strong> the problem. Use a dense array with nulls or some other sentinel at the unused spaces. At most there&#8217;s a factor of two for these common shapes; it may not be worth using a more complicated solution.</li><li>Use a <strong>hash table</strong> instead of dense array. This allows arbitrarily shaped maps, including ones with holes. When you want to access the hex at <code>q,r</code> you access <code>hash_table(hash(q,r))</code> instead. Encapsulate this into the getter/setter in the grid class so that the rest of the game doesn&#8217;t need to know about it.</li><li><strong>Slide</strong> the rows to the left, and use variable sized rows. In many languages a 2D array is an array of arrays; there&#8217;s no reason the arrays have to be the same length. This removes the waste on the right. In addition, if you start the arrays at the leftmost column instead of at 0, you remove the waste on the left. <p>To do this for arbitrary convex shaped maps, you&#8217;d keep an additional array of “first columns”. When you want to access the hex at <code>q,r</code> you access <code>array[r][q -
        first_column[r]]</code> instead. Encapsulate this into the getter/setter in the grid class so that the rest of the game doesn&#8217;t need to know about it. In the diagram <code>first_column</code> is shown on the left side of each row.</p><p>If your maps are fixed shapes, the “first columns” can be calculated on the fly instead of being stored in an array.</p><ul><li>For rectangle shaped maps, <code>first_column[r] ==
        -floor(r/2)</code>, and you&#8217;d end up accessing <code>array[r][q + r/2]</code>, which turns out to be equivalent to converting the coordinates into offset grid coordinates.</li><li>For triangle shaped maps as shown here, <code>first_column[r] == 0</code>, so you&#8217;d access <code>array[r][q]</code> — how convenient! For triangle shaped maps that are oriented the other way (not shown in the diagram), it&#8217;s <code>array[r][q+r]</code>.</li><li>For hexagon shaped maps of radius <code>N</code>, where <code>N = max(abs(x), abs(y), abs(z)</code>, we have <code>first_column[r] == -N - min(0, r)</code>. You&#8217;d access <code>array[r][q + N + min(0, r)]</code>. However, since we&#8217;re starting with some values of <code>r &lt; 0</code>, we also have to offset the row, and use <code>array[r + N][q + N +
        min(0, r)].</code></li><li>For rhombus shaped maps, everything matches nicely, so you can use <code>array[r][q]</code>.</li></ul></li></ol></div><div class="h2banner"><h2 id="wraparound"><a class="anchor" href="#wraparound">#</a>Wraparound maps</h2></div><div class="topic"><div class="float-container"><div><p>In some games you want the map to “wrap” around the edges. In a square map, you can either wrap around the x-axis only (roughly corresponding to a sphere) or both x- and y-axes (roughly corresponding to a torus). Wraparound depends on the map shape, not the tile shape. To wrap around a rectangular map is easy with offset coordinates. I&#8217;ll show how to wrap around a hexagon-shaped map with cube coordinates.</p><p>Corresponding to the center of the map, there are six “mirror” centers. When you go off the map, you subtract the mirror center closest to you until you are back on the main map. In the diagram, try exiting the center map, and watch one of the mirrors enter the map on the opposite side.</p><p>The simplest implementation is to precompute the answers. Make a lookup table storing, for each hex just off the map, the corresponding cube on the other side. For each of the six mirror centers <code>M</code>, and each of the locations on the map <code>L</code>, store <code>mirror_table[cube_add(M, L)] = L</code>. Then any time you calculate a hex that&#8217;s in the mirror table, replace it by the unmirrored version.</p><p>For a hexagonal shaped map with radius <code>N</code>, the mirror centers will be <code>Cube(2*N+1, -N, -N-1)</code> and its <a href="#rotation">six rotations</a>.</p></div><div class="float-right diagram"><svg id="diagram-wraparound" width="500" height="500"></svg></div></div></div><div class="h2banner"><h2 id="pathfinding"><a class="anchor" href="#pathfinding">#</a>Pathfinding</h2></div><div class="topic"><div class="float-container"><p>If you&#8217;re using graph-based pathfinding such as A* or Dijkstra&#8217;s algorithm or Floyd-Warshall, pathfinding on hex grids isn&#8217;t different from pathfinding on square grids. The explanations and code from <a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html">my pathfinding tutorial</a> will work equally well on hexagonal grids.</p><div class="float-right diagram"><svg id="diagram-pathfinding" width="500" height="470"></svg></div><p>Mouse over a hex in the diagram to see the path to it. Click or drag to toggle walls.</p><ol><li><strong>Neighbors</strong>. The sample code I provide in the pathfinding tutorial calls <code>graph.neighbors</code> to get the neighbors of a location. Use the function in the <a href="#neighbors">neighbors</a> section for this. Filter out the neighbors that are impassable.</li><li><strong>Heuristic</strong>. The sample code for A* uses a <code>heuristic</code> function that gives a distance between two locations. Use the <a href="#distances">distance formula</a>, scaled to match the movement costs. For example if your movement cost is 5 per hex, then multiply the distance by 5.</li></ol></div></div><div class="h2banner"><h2 id="references"><a class="anchor" href="#references">#</a>More</h2></div><div class="topic"><p class="note">I have an <a href="implementation.html"><b>guide to implementing your own hex grid library</b></a>, including sample code in C++, Java, C#, Javascript, Haxe, and Python.</p><ul><li>In my <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/grids/">Guide to Grids</a>, I cover axial coordinate systems to address square, triangle, and hexagon edges and corners, and algorithms for the relationships among tiles, edges, and corners. I also show how square and hex grids are related.</li><li>The best early guide I saw to the axial coordinate system was <a href="http://www-cs-students.stanford.edu/~amitp/Articles/HexLOS.html">Clark Verbrugge&#8217;s guide</a>, written in 1996.</li><li>The first time I saw the cube coordinate system was from <a href="http://www-cs-students.stanford.edu/~amitp/Articles/Hexagon2.html">Charles Fu&#8217;s posting to rec.games.programmer</a> in 1994.</li><li><a href="http://devmag.org.za/2013/08/31/geometry-with-hex-coordinates/">DevMag has a nice visual overview of hex math</a> including how to represent areas such as half-planes, triangles, and quadrangles. There&#8217;s a PDF version <a href="http://www.gamelogic.co.za/downloads/HexMath2.pdf">here</a> that goes into more detail. <strong>Highly reocmmended</strong>! The <a href="http://gamelogic.co.za/grids/documentation-contents/quick-start-tutorial/gamelogics-hex-grids-for-unity-and-amit-patels-guide-for-hex-grids/">GameLogic Grids</a> library implements these and many other grid types in Unity.</li><li><a href="http://playtechs.blogspot.com/2007/04/hex-grids.html">James McNeill has a nice visual explanation of grid transformations</a>.</li><li><a href="http://web.archive.org/web/20090205120106/http://sc.tri-bit.com/Hex_Grids">Overview of hex coordinate types</a>: staggered (offset), interlaced, 3d (cube), and trapezoidal (axial).</li><li><a href="http://ondras.github.io/rot.js/manual/#hex/indexing">The Rot.js library</a> has a list of hex coordinate systems: non-orthogonal (axial), odd shift (offset), double width (interlaced), cube.</li><li><a href="http://stackoverflow.com/questions/2049196/generating-triangular-hexagonal-coordinates-xyz">Range for cube coordinates</a>: given a distance, which hexagons are that distance from the given one?</li><li><a href="http://keekerdc.com/2011/03/hexagon-grids-coordinate-systems-and-distance-calculations/">Distances on hex grids</a> using cube coordinates, and reasons to use cube coordinates instead of offset.</li><li><a href="http://www.br-gs.com/tutorial/hexagon-grid.html">This guide</a> explains the basics of measuring and drawing hexagons, using an offset grid.</li><li><a href="http://stackoverflow.com/questions/2459402/hexagonal-grid-coordinates-to-pixel-coordinates">Convert cube hex coordinates to pixel coordinates</a>.</li><li><a href="http://gamedev.stackexchange.com/questions/51264/get-ring-of-tiles-in-hexagon-grid">This thread</a> explains how to generate rings.</li><li>The <a href="http://www.webwargaming.org/hexagoncoordinates.shtml">HexPart</a> system uses both hexes and rectangles to make some of the algorithms easier to work with.</li><li>Are there <a href="http://gamedev.stackexchange.com/questions/49718/vertical-vs-horizontal-hex-grids-pros-and-cons">pros and cons of “pointy topped” and “flat topped” hexagons</a>?</li><li><a href="http://arges-systems.com/blog/2011/01/10/hex-grid-line-of-sight-revisited/">Line of sight in a hex grid</a> with offset coordinates, splitting hexes into triangles</li><li>Hexnet explains how the <a href="http://hexnet.org/content/permutohedron">correspondence between hexagons and cubes</a> goes much deeper than what I described on this page, generalizing to higher dimensions.</li><li>I used the PDF hex grids from <a href="http://incompetech.com/graphpaper/hexagonal/">this page</a> while working out some of the algorithms.</li><li><a href="http://www.reddit.com/r/gamedev/comments/19wmvn/a_data_structure_for_a_game_board_with_hexagonal/c8s9qbe">Generalized Balanced Ternary for hex coordinates</a> seems interesting; I haven&#8217;t studied it.</li><li><a href="http://hexgridutilities.codeplex.com/documentation">Hex-Grid Utilities</a> is a C# library for hex grid math, with neighbors, grids, range finding, path finding, field of view. Open source, MIT license.</li><li>The <a href="http://www.reddit.com/r/gamedev/comments/1dz1tr/">Reddit discussion</a> and <a href="https://news.ycombinator.com/item?id=5809724">Hacker News discussion</a> and <a href="http://www.metafilter.com/128649/Hexagonal-Grids">MetaFilter discussion</a> have more comments and links.</li></ul><p>The code that powers this page is written in a mixture of <a href="http://haxe.org/">Haxe</a> and Javascript: <a href="Cube.hx">Cube.hx</a>, <a href="Hex.hx">Hex.hx</a>, <a href="Grid.hx">Grid.hx</a>, <a href="ScreenCoordinate.hx">ScreenCoordinate.hx</a>, <a href="ui.js">ui.js</a>, and <a href="cubegrid.js">cubegrid.js</a> (for the cube/hex animation). However, if you are looking to write your own hex grid library, I suggest instead looking at <a href="implementation.html">my guide to implementation</a>.</p><p>There are more things I want to do for this guide. I&#8217;m <a href="https://trello.com/card/hexagonal-grids-2-0/4f1dbfdc0fc2508c1b238d7d/52">keeping a list on Trello</a>. Do you have suggestions for things to change or add? Comment below.</p></div></div><div class="divider"></div><div class="divider-disqus" style="font-size:large">
            Email me at
            
            <a class="email" href="mailto:redblobgames@gmail.com">redblobgames@gmail.com</a>,
                or tweet to <a href="https://twitter.com/redblobgames">@redblobgames</a>,
              
            or post a public comment:
          </div><div class="comments" role="complementary"><div id="disqus_thread" class="main"></div><script>
              (function() {
              var dsq = document.createElement('script');
              dsq.type = 'text/javascript'; dsq.async = true;
              
                  dsq.src = '//redblobgames.disqus.com/embed.js';
                
              if (document.location.hostname != 'localhost') (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
            </script><noscript><a href="//redblobgames.disqus.com/?url=ref">View the discussion thread.</a></noscript></div><div class="footer" role="contentinfo"><div style="float:left;width:300px;margin-right:40px"><address>
		  Copyright © 2016
                  <a rel="author home copyright" href="//www.redblobgames.com/">Red Blob Games</a></address></div><div style="text-align:right">
	     <script src="_compiled_hexlib.js"></script><script src="ui.js"></script><script src="cubegrid.js"></script> Created 11 Mar 2013 with <a href="http://haxe.org/">Haxe</a> and <a href="http://d3js.org/">D3.js</a> ;  <!-- hhmts start -->Last modified: 24 Jul 2016<!-- hhmts end --></div><br style="clear:both"><!-- Start of counters --><script><!--
                  var sc_project=417499;
                  var sc_invisible=1;
                  var sc_security="";
(function() {
      var script = document.createElement('script');
      script.type = 'text/javascript'; script.async = true;
      script.src = 'http://statcounter.com/counter/counter_xhtml.js';
      if (document.location.hostname != 'localhost') document.getElementsByTagName('body')[0].appendChild(script);
  })();
                //--></script><noscript><div class="statcounter"><a class="statcounter" href="http://statcounter.com/"><img class="statcounter" src="http://c.statcounter.com/417499/0//1/" alt=""></a></div></noscript><script>
var _gap = _gap || [];
_gap.push(['_setAccount', 'UA-79181-1']);
_gap.push(['_setDomainName', 'redblobgames.com']);
_gap.push(['_setAllowLinker', true]);
_gap.push(['_trackPageview']);
_gap.push(['_gapTrackBounceViaTime', 30]);
_gap.push(['_gapTrackBounceViaScroll', 25]);
_gap.push(['_gapTrackReads', 60, 10]);
_gap.push(['_gapTrackLinkClicks']);
if (document.location.hostname != 'localhost') (function() {
    var gap = document.createElement('script');
    gap.async = true;
    gap.type = 'text/javascript';
    gap.src = '/js/gap.min.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gap, s);
})();
              </script><!-- End of counters --></div></body></html>
